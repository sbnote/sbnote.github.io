## sscanf的高级用法

 sscanf(recvbuf,"%*[^/]/%[^ ]s",buf_rev); 
 sscanf(buf, "GET /%[^ ]", buf_rev); 

这个是在一个webserver.c里面的例子，通过sscanf（）语句可以找到和它前面相匹配的语句然后打印出后面需要的东西，下面说下%[]:
其基本格式为 %[set]，表示将接收一个由set指定格式的字符串，其中set表示可接受的字符集合。

   set一般有两种情况：

​                一种是"^set"表示非, 即在输入的字符串中将匹配所有不在set中出现的字符，
          遇到set中的字符时停止匹配。
                另一种是"set"表示在输入的字符串中将匹配所有在set中出现的字符，
          遇到非set中的字符时停止匹配。

 如：
 scanf("%[^&]",buf); //当输入的字符中出现"&"时停止匹配,如果输入hello&world,则buf=hello;
 scanf("%[^290#*]",buf); //当输入aidc＃ad时,则buf=aidc,
       即当输入出现了"#"时不再将输入内容放入buf
 scanf("%[dlza#i]",buf);//只匹配"dlza#i"这几个字符，
       如果不是这几个字符则停止匹配，如当输入ai＃dcad时,buf=ai#d,因为c不在[dlza#i]中.
 
特殊情况:

   (1)如果要匹配"^"时,当然不能直接放在[]中,所以可以用%[ab^cd]这种方式,
   (2)当要匹配右方括号"]"时,应把其放在set中第一个位置，如"%[]abc]"表示匹配的字符集为{], a, b, c}，又如"%[^]abc]"表示匹配所有非"], a, b, c"中的字符

   另外,还可以使用"-" 如%[a-z]表示只匹配abcd....yz等小写的字母;
   %[0-9]表示只匹配0,1,2...9等数字;

  (3) * 表示跳过，如：

int main()
{
 char buf[100]="123:asdfasd:2342342:liman:host:34234:hello";
 char user[20]="";
 char host[20]="";
 char msg[20]="";
 int cmd = 0; 
 sscanf(buf, "%*d:%*[^:]:%*[^:]:%[^:]:%[^:]:%d:%s", user, host, &cmd, msg);
 return 0;
}

结果：user="liman",host="host",cmd=34234,msg=hello
    注意，“-”的字符只有在其左右两边都有有效字符时才有这个作用，否则被认为是普通字符，如“a-c-e-g”匹配的字符为｛a, b, c, -, e, f, g｝，这样也为输入“-”字符提供了方法。
sscanf函数的高级用法
sscanf与scanf类似，都是用于输入的，只是后者以屏幕(stdin)为输入源，前者以固定字符串为输入源。
函数原型：
int scanf( const char *format [,argument]... );
其中的format可以是一个或多个：
{%[*][width][{h|l|I64|L}]type|' '|'\t'|'\n'|非%符号}，
注：
1)、 * 亦可用于格式中, (即 %*d 和 %*s) 加了星号 (*) 表示跳过此数据不读入。
 (也就是不把此数据读入参数中) 
2)、{a|b|c}表示a,b,c中选一，[d],表示可以有d也可以没有d。 
3）、width:宽度，一般可以忽略，用法如：
const  char sourceStr[] = "hello, world";
char buf[10] = {0};
sscanf(sourceStr, "%5s", buf);   //%5s，只取5个字符
cout << buf<< endl;
结果为:hello
4）、{h|I|I64|L}:参数的size,通常h表示单字节size，I表示2字节 size,
  L表示4字节size(double例外),l64表示8字节size。
5）、type :这就很多了，就是%s,%d之类。
6）、特别的：%*[width] [{h|l|I64|L}]type 表示满足该条件的被过滤掉，
 不会向目标参数中写入值。如：
const char sourceStr[] = "hello, world";
char  buf[10] = {0};
sscanf(sourceStr, "%*s%s", buf);
//%*s表示第一个匹配到的%s被过滤掉，即hello被过滤了
cout << buf<< endl;
结果为:world
5）、支持集合操作：
%[a-z]  表示匹配a到z中任意字符，贪婪性(尽可能多的匹配)
%[aB']  匹配a、B、'中一员，贪婪性
%[^a]   匹配非a的任意字符，贪婪性
和正则表达式很相似，而且仍然支持过滤，即可以有%*[a-z]。
例子：
1. 常见用法。
char buf[512] = {0};
sscanf("123456 ", "%s", buf);
printf("%s\n", buf);
结果为：123456 
2. 取指定长度的字符串。如在下例中，取最大长度为4字节的字符串。
    sscanf("123456 ", "%4s", buf);
 printf("%s\n", buf);
 结果为：1234 
3. 取到指定字符为止的字符串。如在下例中，取遇到空格为止字符串。
    sscanf("123456 abcdedf", "%[^ ]", buf);
 printf("%s\n", buf);
 结果为：123456 
4.  取仅包含指定字符集的字符串。如在下例中，取仅包含1到9和小写字母的字符串。
    sscanf("123456abcdedfBCDEF", "%[1-9a-z]", buf);
 printf("%s\n", buf);
 结果为：123456abcdedf 
5.  取到指定字符集为止的字符串。如在下例中，取遇到大写字母为止的字符串。
    sscanf("123456abcdedfBCDEF", "%[^A-Z]", buf);
 printf("%s\n", buf);
 结果为：123456abcdedf 
6、给定一个字符串iios/12DDWDFF@122，获取 / 和 @ 之间的字符串，
 先将 "iios/"过滤掉，再将非'@'的一串内容送到buf中
 sscanf("iios/12DDWDFF@122", "%*[^/]/%[^@]", buf);
 printf("%s\n", buf);
 结果为：12DDWDFF 
7、给定一个字符串““hello, world”，仅保留world。（注意：“，”之后有一空格）
 sscanf(“hello, world”,  "%*s%s",  buf);  
 printf("%s\n", buf);
 结果为：world
 %*s表示第一个匹配到的%s被过滤掉，即hello被过滤了，如果没有空格则结果为NULL。 
8、分隔字符串2006:03:18
 int a, b, c;
 sscanf("2006:03:18", "%d:%d:%d", a, b, c); 
9、分隔字符串2006:03:18 - 2006:04:18
 char sztime1[16] = "", sztime2[16] = "";
 sscanf("2006:03:18 - 2006:04:18", "%s - %s", sztime1, sztime2); 
10、分隔字符串2006:03:18-2006:04:18
 char sztime1[16] = "", sztime2[16] = "";
 sscanf("2006:03:18-2006:04:18", "%[0-9,:] - %[0-9,:]", sztime1, sztime2);
 仅仅是取消了‘-’两边的空格，却打破了%s对字符串的界定format-type中有%[]这样的type  field。如果读取的字符串，不是以空格来分隔的话，就可以使用%[]。%[]类似于一个正则表达式。 [a-z]表示读取a-z的所有字符，[^a-z]表示读取除a-z以外的所有字符。 
 sscanf的功能很类似于正则表达式, 但却没有正则表达式强大,所以如果对于比较复杂的字符串处 理,建议使用正则表达式.

正则表达式的基本用法：
1、“.”为通配符，表示任何一个字符，例如：“a.c”可以匹配“anc”、“abc”、“acc”；
2、“[]”，在[]内可以指定要求匹配的字符，例如：“a[nbc]c”可以匹配“anc”、“abc”、"acc"；但不可以匹配“ancc”,a到z可以写成[a-z],0到9可以写成[0-9];
3、数量限定符号，表示匹配次数（或者叫做长度）的符号,包括：
“*”  0次或者多次
“+”  1次或者多次
“?”  0次或者1次
“{n}”    匹配n次，n为整数
“{n,m}”  匹配从n到m之间的某个数的次数；n和m都是整数；
“{n,}”   匹配n到无穷次之间任意次数；
“{,m}”   匹配0到m之间任意次数；
数量限定符号放到匹配格式的后面，例如：电话号码：024-84820482，02484820482(假设前面3或者4位，后面7或者8位，并且中间的减号可有可无)，都是符合规定的，那么可以用如下格式来匹配：[0-9]{3,4} \-? [0-9]{7,8}；注意：“\”为转义字符，因为“-”在正则表达式用有代表一个范围的意义，例如：前面所说的[0-9]，所以它需要转义字符“\”进行转义才可使用；
4、^为否符号，表示不想匹配的符号，例如：[^z][a-z]+可以匹配所有除"z"开头的以外的所有字
如果^放到[]的外边则表示以[]开头的字符串；^[az][a-z]+表示a或者z开头的长度大于等于2的英文字符串；
5、“|”或运算符，例如：a[n|bc|cb]c可以匹配“abcc”,“anc”,“acbc”；
6、“$”以它前面的字符结尾的；例如：ab+$就可以被“abb”，“ab”匹配；
7、一些简单表示方法：\d表示[0-9];\D表示[^0-9];\w表示[A-Z0-9];\W表示[^A-Z0-9];\s表示[\t\n\r\f],就是空格字符包括tab，空格等等;\S表示[^\t\n\r\f]，就是非空格字符;